#' Annotate human cell types using SinglR
#'
#' Uses the SingleR::SingleR() function to label cell types according to expression profiles 
#' from the databases made available via the the `{celldex}` package. The Seurat object per-cell 
#' metadata is updated with `{ref}_type`, `{ref}_type_fine`, `{ref}_type`, `{ref}_type`, columns. 
#' Cell types are taken from the pruned labels in the `celldex` package.
#' 
#' DICE: 1561 bulk RNA-seq samples of sorted cell populations from the Database of Immune Cell Expression
#' HPCA: 713 microarray samples from the Human Primary Cell Atlas
#' BED: 259 bulk RNA-seq samples generated by Blueprint and ENCODE from pure populations of stroma and immune cells
#' MID: 114 bulk RNA-seq samples of sorted immune cell populations that can be found in GSE107011
#' NHD: 211 bulk human microarray samples of sorted hematopoietic cell populations that can be found in GSE24759
#' See for details https://bioconductor.org/packages/release/data/experiment/html/celldex.html
#'
#' @name seurat_annotate_cell_type
#' @param seurat_object a Seurat object or a path to a seurat object saved as "qs" format
#' @ref reference database, c("DICE", "HPCA", "BED", "MID", "NHD"), Default = "DICE"
#' @return a Seurat object with cell type annotations
#' @source https://bioconductor.org/books/release/SingleRBook/
#' @author Denis O'Meally, Yu-Husan Fu
#' @export
seurat_singleR_hsa_cell_type <- function(seurat_object, ref = "DICE") {
    seurat_object <- load_seurat(seurat_object)

    if (!isNormalized(seurat_object)) {
        seurat_object <- NormalizeData(seurat_object)
        }

    # Setup parallel processing
    resources <- hprcc::slurm_allocation()

    BiocParallel::register(
        BiocParallel::MulticoreParam(workers = resources$CPUs, progressbar = TRUE)
        )

    # Make it reproducible
    set.seed(42)

    # Pick the ref
    if (ref=="DICE") {
        celldex_ref <- celldex::DatabaseImmuneCellExpressionData()
    } else if (ref=="HPCA") {
        celldex_ref <- celldex::HumanPrimaryCellAtlasData()
    } else if (ref=="BED") {
        celldex_ref <- celldex::BlueprintEncodeData()
    } else if (ref=="MID") {
        celldex_ref <- celldex::MonacoImmuneData()
    } else if (ref=="NHD") {
        celldex_ref <- celldex::NovershternHematopoieticData()
    } else {
        stop("Invalid ref. Choose one of c('DICE', 'HPCA', 'BED', 'MID', 'NHD')")
        }

    Seurat::DefaultAssay(seurat_object) <- "RNA"
    # One database (HPAC) has a mislabel ðŸ¤¦ðŸ¼
    celldex_label <- celldex_ref |> colData() |> as_tibble()  %>%
        mutate(label.main = ifelse(ref == "HPCA" & label.main == "BM & Prog.", "BM", label.main))
    
    cell_labels <- SingleR::SingleR(
        test = Seurat::GetAssayData(seurat_object, assay = "RNA", layer = "counts"),
        ref = celldex_ref,
        labels = celldex_label$label.fine,
        assay.type.test=1,
        BPPARAM = BiocParallel::bpparam()
    ) 
    # drop the scores: it's a matrix of scores for each cell type vs each cell type. We just want 
    # the label and the delta.next, which is the difference between the score for the next best cell type
    cell_labels$scores<-NULL
    
    # rename
    cell_label_table <- cell_labels |> 
        rename(labels="label.fine") |> 
        as.data.frame()|> 
        tibble::rownames_to_column(var = "cell") |> 
        as_tibble()

    cell_type <- cell_label_table |>
            dplyr::left_join(celldex_label |> unique(), by = c("label.fine")) |>
            dplyr::mutate(
                !!sym(paste0(ref, "_type_fine")) := stringr::str_replace(pruned.labels, " \\s*\\([^\\)]+\\)", ""),
                !!sym(paste0(ref, "_type")) := label.main,
                !!sym(paste0(ref, "_ont")) := label.ont,
                !!sym(paste0(ref, "_delta_next")) := delta.next
            ) |> 
            select(cell, matches(ref)) |> unique()
    
    sample_id <- seurat_object@meta.data$orig.ident[1]

    cell_type_path <- glue::glue("{analysis_cache}/cell_type_out/{sample_id}_{ref}_cell_type.csv")
    dir.create(dirname(cell_type_path), showWarnings = FALSE, recursive = TRUE)

    cell_type |> write_csv(cell_type_path)

    return(cell_type_path)
}
